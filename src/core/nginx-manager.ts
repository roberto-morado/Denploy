import { join } from "@std/path";
import { ensureDir, exists } from "@std/fs";
import { config } from "../config.ts";
import { logger } from "../utils/logger.ts";
import type { App } from "../db/models.ts";

export class NginxManager {
  async generateAppConfig(app: App): Promise<void> {
    try {
      const configContent = this.buildConfigContent(app);
      const configPath = join(
        config.nginx.configPath,
        `${app.subdomain}.${config.platform.domain}.conf`
      );

      await ensureDir(config.nginx.configPath);
      await Deno.writeTextFile(configPath, configContent);

      logger.info(`Generated Nginx config for ${app.subdomain}.${config.platform.domain}`);

      // Reload Nginx to apply changes
      await this.reloadNginx();
    } catch (error) {
      logger.error("Failed to generate Nginx config", { error: error.message });
      throw error;
    }
  }

  async removeAppConfig(app: App): Promise<void> {
    try {
      const configPath = join(
        config.nginx.configPath,
        `${app.subdomain}.${config.platform.domain}.conf`
      );

      if (await exists(configPath)) {
        await Deno.remove(configPath);
        logger.info(`Removed Nginx config for ${app.subdomain}.${config.platform.domain}`);

        // Reload Nginx to apply changes
        await this.reloadNginx();
      }
    } catch (error) {
      logger.error("Failed to remove Nginx config", { error: error.message });
      throw error;
    }
  }

  private buildConfigContent(app: App): string {
    return `# Nginx configuration for ${app.name}
# Generated by Denploy at ${new Date().toISOString()}

server {
    listen 80;
    server_name ${app.subdomain}.${config.platform.domain};

    # Logs
    access_log ${config.logs.path}/nginx/${app.subdomain}-access.log;
    error_log ${config.logs.path}/nginx/${app.subdomain}-error.log;

    # Proxy settings
    location / {
        proxy_pass http://localhost:${app.port};
        proxy_http_version 1.1;

        # Headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Buffering
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # Health check endpoint
    location /health {
        access_log off;
        proxy_pass http://localhost:${app.port}/health;
    }

    # Max body size
    client_max_body_size 50M;
}
`;
  }

  private async reloadNginx(): Promise<void> {
    try {
      // Test Nginx configuration first
      const testCommand = new Deno.Command("nginx", {
        args: ["-t"],
        stdout: "piped",
        stderr: "piped",
      });

      const testProcess = testCommand.spawn();
      const testStatus = await testProcess.status;

      if (!testStatus.success) {
        const stderr = await testProcess.stderr.getReader().read();
        const errorText = new TextDecoder().decode(stderr.value);
        throw new Error(`Nginx configuration test failed: ${errorText}`);
      }

      // Reload Nginx
      const reloadCommand = new Deno.Command("nginx", {
        args: ["-s", "reload"],
        stdout: "piped",
        stderr: "piped",
      });

      const reloadProcess = reloadCommand.spawn();
      const reloadStatus = await reloadProcess.status;

      if (!reloadStatus.success) {
        const stderr = await reloadProcess.stderr.getReader().read();
        const errorText = new TextDecoder().decode(stderr.value);
        throw new Error(`Nginx reload failed: ${errorText}`);
      }

      logger.info("Nginx reloaded successfully");
    } catch (error) {
      logger.error("Failed to reload Nginx", { error: error.message });
      // Don't throw - log warning and continue
      logger.warn("Nginx reload failed, but continuing. Manual reload may be required.");
    }
  }

  async createNginxDirectories(): Promise<void> {
    await ensureDir(config.nginx.configPath);
    await ensureDir(config.nginx.templatePath);
    await ensureDir(join(config.logs.path, "nginx"));
  }

  async generateMainConfig(): Promise<void> {
    const mainConfigPath = join(config.nginx.templatePath, "denploy-main.conf");
    const mainConfigContent = `# Denploy Main Nginx Configuration

# Include all app configurations
include ${config.nginx.configPath}/*.conf;

# Main platform server
server {
    listen 80;
    server_name ${config.platform.domain};

    location / {
        proxy_pass http://localhost:${config.platform.port};
        proxy_http_version 1.1;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    client_max_body_size 50M;
}
`;

    await Deno.writeTextFile(mainConfigPath, mainConfigContent);
    logger.info("Generated main Nginx configuration");
  }
}

// Singleton instance
let nginxManagerInstance: NginxManager | null = null;

export function getNginxManager(): NginxManager {
  if (!nginxManagerInstance) {
    nginxManagerInstance = new NginxManager();
  }
  return nginxManagerInstance;
}
